package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
)

const (
	baseTemplate = `
/*
* This file autogenerated;
*
* DO NOT EDIT
* Generated by https://github.com/oasgo/oasgo
*/

package {{.PackageName}}
type (
	{{ range $r := .References }}
		{{ $r.Reference.RenderDefinition }}
	{{ end }}
)

{{ range $f := .Functions -}}
func {{ $f.RenderSignature }} {
		{{ $f.RenderBody }}
	}
{{ end }}
`
	structTemplate = `
{{$.Name}} struct {
	{{ range $p :=  $.Properties }}
	{{- $p.Name }} {{ $p.Reference.RenderName }}
	{{ end }}
}
`
	arrayTemplate     = `{{$.Name}} []{{$.ItemsType.Reference.RenderName}}`
	signatureTemplate = `` +
		`{{$.Name}}(r *http.Request)` +
		`({{range $i, $a := $.Output}}{{$a.Property.Name}} ` +
		`{{$a.Property.Reference.RenderName}}{{- if lt (inc $i) (len $.Output) -}}, {{- end -}}` +
		`{{end}})`
)

type Reference interface {
	RenderDefinition() string
	RenderLiteral() string
	RenderName() string
}

type Context struct {
	PackageName string
	References  map[string]property
	Functions   []Function
}
type Function struct {
	Name   string
	Output []Param
}

type Param struct {
	In       string
	Required bool
	Property property
}

type Struct struct {
	Properties []property
	Name       string
}

type Slice struct {
	ItemsType property
	Name      string
}

type String struct{}
type Integer struct{}
type Number struct{}

type property struct {
	Name       string
	SourceName string
	Reference  Reference
}

func (f *Function) RenderSignature() string {
	buf := bytes.NewBuffer([]byte{})
	tmpl, err := template.New("signature").Funcs(template.FuncMap{
		"inc": func(i int) int {
			return i + 1
		},
	}).Parse(signatureTemplate)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = tmpl.Execute(buf, f)
	if err != nil {
		fmt.Println(err)
		os.Exit(2)
	}

	return buf.String()
}

func newParam(in string, required bool, p property) Param {
	p.Name = ToCamelCase(false, p.Name)
	return Param{in, required, p}
}

func (f *Function) RenderBody() string {
	return ""
}

func (s *String) RenderLiteral() string    { return "string" }
func (s *String) RenderName() string       { return "string" }
func (s *String) RenderDefinition() string { return "" }

func (s *Integer) RenderLiteral() string    { return "int64" }
func (s *Integer) RenderName() string       { return "int64" }
func (s *Integer) RenderDefinition() string { return "" }

func (s *Number) RenderLiteral() string    { return "float64" }
func (s *Number) RenderName() string       { return "float64" }
func (s *Number) RenderDefinition() string { return "" }

func (s *Slice) RenderLiteral() string { return s.Name }
func (s *Slice) RenderName() string    { return "[]" + s.ItemsType.Reference.RenderName() }

func (s *Slice) RenderDefinition() string {
	buf := bytes.NewBuffer([]byte{})

	tmpl, err := template.New("slice").Parse(arrayTemplate)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = tmpl.Execute(buf, s)
	if err != nil {
		fmt.Println(err)
		os.Exit(2)
	}

	return buf.String()

}

func (s *Struct) RenderLiteral() string { return s.Name }
func (s *Struct) RenderName() string    { return s.Name }

func (s *Struct) RenderDefinition() string {
	buf := bytes.NewBuffer([]byte{})

	tmpl, err := template.New("struct").Parse(structTemplate)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	err = tmpl.Execute(buf, s)
	if err != nil {
		fmt.Println(err)
		os.Exit(2)
	}

	return buf.String()

}

func (ctx *Context) setProperty(schema *Schema, name, pname string) property {
	refName := ToCamelCase(true, pname, name)
	if p, ok := ctx.References[refName]; ok {
		return p
	}
	p := property{Name: ToCamelCase(true, name)}
	switch schema.Type {
	case "object":
		ps := &Struct{Name: refName, Properties: []property{}}
		for n, s := range schema.Properties {
			ps.Properties = append(ps.Properties, ctx.setProperty(s, n, refName))
		}
		p.Reference = ps
		ctx.References[refName] = p
	case "string":
		p.Reference = &String{}
	case "integer":
		p.Reference = &Integer{}
	case "array":
		p.Reference = &Slice{Name: refName, ItemsType: ctx.setProperty(schema.Items, "", refName)}
	case "number":
		p.Reference = &Number{}
	default:
		log.Fatalf("unsupported type %s", schema.Type)
	}
	return p
}

func (ctx *Context) getParams(ps []*Parameter, opID string) []Param {
	inputs := []Param{}
	for _, p := range ps {
		inputs = append(inputs, newParam(p.In, p.Required, ctx.setProperty(p.Schema, p.Name, opID)))
	}
	return inputs
}

func renderTree(s *Swagger) {

	tmpl, err := template.New("handlers").Parse(baseTemplate)
	if err != nil {
		os.Stderr.WriteString("Parse tmpl error: " + err.Error())
		os.Exit(1)
	}

	c := Context{
		PackageName: "mypacakge",
		References:  make(map[string]property),
		Functions:   []Function{},
	}
	for n, schema := range s.Components.Schemas {
		c.setProperty(schema, n, "")
	}

	for _, m := range s.Paths {
		if m.GET != nil {
			c.Functions = append(c.Functions, Function{Name: ToCamelCase(true, m.GET.OperationID), Output: c.getParams(m.GET.Parameters, m.GET.OperationID)})
		}
		if m.POST != nil {
			c.Functions = append(c.Functions, Function{Name: ToCamelCase(true, m.POST.OperationID), Output: c.getParams(m.POST.Parameters, m.POST.OperationID)})
		}
		if m.PUT != nil {
			c.Functions = append(c.Functions, Function{Name: ToCamelCase(true, m.PUT.OperationID), Output: c.getParams(m.PUT.Parameters, m.PUT.OperationID)})
		}
		if m.DELETE != nil {
			c.Functions = append(c.Functions, Function{Name: ToCamelCase(true, m.DELETE.OperationID), Output: c.getParams(m.DELETE.Parameters, m.DELETE.OperationID)})
		}
	}

	err = tmpl.Execute(os.Stdout, c)
	if err != nil {
		os.Stderr.WriteString("Execute tmpl error: " + err.Error())
		os.Exit(2)
	}
}
func ToCamelCase(upper bool, names ...string) (out string) {
	bs := []byte(strings.Join(names, "_"))
	in := strings.Trim(string(bs), " ")

	isNext := false
	for i, v := range in {
		if (v >= 'A' && v <= 'Z') || (v >= 'a' && v <= 'z') {
			if i == 0 {
				if !upper {
					out += strings.ToLower(string(v))
				} else {
					out += strings.ToUpper(string(v))
				}
			} else {
				if isNext {
					out += strings.ToUpper(string(v))
				} else {
					out += string(v)
				}
			}
		}
		if v >= '0' && v <= '9' {
			out += string(v)
		}
		if v == '_' || v == ' ' || v == '-' {
			isNext = true
		} else {
			isNext = false
		}
	}
	return
}
